// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files
// DO NOT EDIT

use glib::error::ErrorDomain;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::Quark;
use glib::StaticType;
use glib::Type;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteCursorBlinkMode")]
pub enum CursorBlinkMode {
    #[doc(alias = "VTE_CURSOR_BLINK_SYSTEM")]
    System,
    #[doc(alias = "VTE_CURSOR_BLINK_ON")]
    On,
    #[doc(alias = "VTE_CURSOR_BLINK_OFF")]
    Off,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CursorBlinkMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CursorBlinkMode::{}",
            match *self {
                Self::System => "System",
                Self::On => "On",
                Self::Off => "Off",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for CursorBlinkMode {
    type GlibType = ffi::VteCursorBlinkMode;

    fn into_glib(self) -> ffi::VteCursorBlinkMode {
        match self {
            Self::System => ffi::VTE_CURSOR_BLINK_SYSTEM,
            Self::On => ffi::VTE_CURSOR_BLINK_ON,
            Self::Off => ffi::VTE_CURSOR_BLINK_OFF,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteCursorBlinkMode> for CursorBlinkMode {
    unsafe fn from_glib(value: ffi::VteCursorBlinkMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::VTE_CURSOR_BLINK_SYSTEM => Self::System,
            ffi::VTE_CURSOR_BLINK_ON => Self::On,
            ffi::VTE_CURSOR_BLINK_OFF => Self::Off,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CursorBlinkMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::vte_cursor_blink_mode_get_type()) }
    }
}

impl glib::value::ValueType for CursorBlinkMode {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CursorBlinkMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CursorBlinkMode {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteCursorShape")]
pub enum CursorShape {
    #[doc(alias = "VTE_CURSOR_SHAPE_BLOCK")]
    Block,
    #[doc(alias = "VTE_CURSOR_SHAPE_IBEAM")]
    Ibeam,
    #[doc(alias = "VTE_CURSOR_SHAPE_UNDERLINE")]
    Underline,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CursorShape {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "CursorShape::{}",
            match *self {
                Self::Block => "Block",
                Self::Ibeam => "Ibeam",
                Self::Underline => "Underline",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for CursorShape {
    type GlibType = ffi::VteCursorShape;

    fn into_glib(self) -> ffi::VteCursorShape {
        match self {
            Self::Block => ffi::VTE_CURSOR_SHAPE_BLOCK,
            Self::Ibeam => ffi::VTE_CURSOR_SHAPE_IBEAM,
            Self::Underline => ffi::VTE_CURSOR_SHAPE_UNDERLINE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteCursorShape> for CursorShape {
    unsafe fn from_glib(value: ffi::VteCursorShape) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::VTE_CURSOR_SHAPE_BLOCK => Self::Block,
            ffi::VTE_CURSOR_SHAPE_IBEAM => Self::Ibeam,
            ffi::VTE_CURSOR_SHAPE_UNDERLINE => Self::Underline,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for CursorShape {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::vte_cursor_shape_get_type()) }
    }
}

impl glib::value::ValueType for CursorShape {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CursorShape {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CursorShape {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteEraseBinding")]
pub enum EraseBinding {
    #[doc(alias = "VTE_ERASE_AUTO")]
    Auto,
    #[doc(alias = "VTE_ERASE_ASCII_BACKSPACE")]
    AsciiBackspace,
    #[doc(alias = "VTE_ERASE_ASCII_DELETE")]
    AsciiDelete,
    #[doc(alias = "VTE_ERASE_DELETE_SEQUENCE")]
    DeleteSequence,
    #[doc(alias = "VTE_ERASE_TTY")]
    Tty,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for EraseBinding {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "EraseBinding::{}",
            match *self {
                Self::Auto => "Auto",
                Self::AsciiBackspace => "AsciiBackspace",
                Self::AsciiDelete => "AsciiDelete",
                Self::DeleteSequence => "DeleteSequence",
                Self::Tty => "Tty",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for EraseBinding {
    type GlibType = ffi::VteEraseBinding;

    fn into_glib(self) -> ffi::VteEraseBinding {
        match self {
            Self::Auto => ffi::VTE_ERASE_AUTO,
            Self::AsciiBackspace => ffi::VTE_ERASE_ASCII_BACKSPACE,
            Self::AsciiDelete => ffi::VTE_ERASE_ASCII_DELETE,
            Self::DeleteSequence => ffi::VTE_ERASE_DELETE_SEQUENCE,
            Self::Tty => ffi::VTE_ERASE_TTY,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteEraseBinding> for EraseBinding {
    unsafe fn from_glib(value: ffi::VteEraseBinding) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::VTE_ERASE_AUTO => Self::Auto,
            ffi::VTE_ERASE_ASCII_BACKSPACE => Self::AsciiBackspace,
            ffi::VTE_ERASE_ASCII_DELETE => Self::AsciiDelete,
            ffi::VTE_ERASE_DELETE_SEQUENCE => Self::DeleteSequence,
            ffi::VTE_ERASE_TTY => Self::Tty,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for EraseBinding {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::vte_erase_binding_get_type()) }
    }
}

impl glib::value::ValueType for EraseBinding {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for EraseBinding {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for EraseBinding {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v0_50", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_50")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteFormat")]
pub enum Format {
    #[doc(alias = "VTE_FORMAT_TEXT")]
    Text,
    #[doc(alias = "VTE_FORMAT_HTML")]
    Html,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v0_50", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_50")))]
impl fmt::Display for Format {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Format::{}",
            match *self {
                Self::Text => "Text",
                Self::Html => "Html",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v0_50", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_50")))]
#[doc(hidden)]
impl IntoGlib for Format {
    type GlibType = ffi::VteFormat;

    fn into_glib(self) -> ffi::VteFormat {
        match self {
            Self::Text => ffi::VTE_FORMAT_TEXT,
            Self::Html => ffi::VTE_FORMAT_HTML,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v0_50", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_50")))]
#[doc(hidden)]
impl FromGlib<ffi::VteFormat> for Format {
    unsafe fn from_glib(value: ffi::VteFormat) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::VTE_FORMAT_TEXT => Self::Text,
            ffi::VTE_FORMAT_HTML => Self::Html,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v0_50", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_50")))]
impl StaticType for Format {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::vte_format_get_type()) }
    }
}

#[cfg(any(feature = "v0_50", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_50")))]
impl glib::value::ValueType for Format {
    type Type = Self;
}

#[cfg(any(feature = "v0_50", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_50")))]
unsafe impl<'a> FromValue<'a> for Format {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v0_50", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_50")))]
impl ToValue for Format {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VtePtyError")]
pub enum PtyError {
    #[doc(alias = "VTE_PTY_ERROR_PTY_HELPER_FAILED")]
    PtyHelperFailed,
    #[doc(alias = "VTE_PTY_ERROR_PTY98_FAILED")]
    Pty98Failed,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PtyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "PtyError::{}",
            match *self {
                Self::PtyHelperFailed => "PtyHelperFailed",
                Self::Pty98Failed => "Pty98Failed",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for PtyError {
    type GlibType = ffi::VtePtyError;

    fn into_glib(self) -> ffi::VtePtyError {
        match self {
            Self::PtyHelperFailed => ffi::VTE_PTY_ERROR_PTY_HELPER_FAILED,
            Self::Pty98Failed => ffi::VTE_PTY_ERROR_PTY98_FAILED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VtePtyError> for PtyError {
    unsafe fn from_glib(value: ffi::VtePtyError) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::VTE_PTY_ERROR_PTY_HELPER_FAILED => Self::PtyHelperFailed,
            ffi::VTE_PTY_ERROR_PTY98_FAILED => Self::Pty98Failed,
            value => Self::__Unknown(value),
        }
    }
}

impl ErrorDomain for PtyError {
    fn domain() -> Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::vte_pty_error_quark()) }
    }

    fn code(self) -> i32 {
        self.into_glib()
    }

    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match code {
            ffi::VTE_PTY_ERROR_PTY_HELPER_FAILED => Some(Self::PtyHelperFailed),
            ffi::VTE_PTY_ERROR_PTY98_FAILED => Some(Self::Pty98Failed),
            value => Some(Self::__Unknown(value)),
        }
    }
}

impl StaticType for PtyError {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::vte_pty_error_get_type()) }
    }
}

impl glib::value::ValueType for PtyError {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PtyError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PtyError {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v0_52", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_52")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteTextBlinkMode")]
pub enum TextBlinkMode {
    #[doc(alias = "VTE_TEXT_BLINK_NEVER")]
    Never,
    #[doc(alias = "VTE_TEXT_BLINK_FOCUSED")]
    Focused,
    #[doc(alias = "VTE_TEXT_BLINK_UNFOCUSED")]
    Unfocused,
    #[doc(alias = "VTE_TEXT_BLINK_ALWAYS")]
    Always,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v0_52", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_52")))]
impl fmt::Display for TextBlinkMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "TextBlinkMode::{}",
            match *self {
                Self::Never => "Never",
                Self::Focused => "Focused",
                Self::Unfocused => "Unfocused",
                Self::Always => "Always",
                _ => "Unknown",
            }
        )
    }
}

#[cfg(any(feature = "v0_52", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_52")))]
#[doc(hidden)]
impl IntoGlib for TextBlinkMode {
    type GlibType = ffi::VteTextBlinkMode;

    fn into_glib(self) -> ffi::VteTextBlinkMode {
        match self {
            Self::Never => ffi::VTE_TEXT_BLINK_NEVER,
            Self::Focused => ffi::VTE_TEXT_BLINK_FOCUSED,
            Self::Unfocused => ffi::VTE_TEXT_BLINK_UNFOCUSED,
            Self::Always => ffi::VTE_TEXT_BLINK_ALWAYS,
            Self::__Unknown(value) => value,
        }
    }
}

#[cfg(any(feature = "v0_52", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_52")))]
#[doc(hidden)]
impl FromGlib<ffi::VteTextBlinkMode> for TextBlinkMode {
    unsafe fn from_glib(value: ffi::VteTextBlinkMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::VTE_TEXT_BLINK_NEVER => Self::Never,
            ffi::VTE_TEXT_BLINK_FOCUSED => Self::Focused,
            ffi::VTE_TEXT_BLINK_UNFOCUSED => Self::Unfocused,
            ffi::VTE_TEXT_BLINK_ALWAYS => Self::Always,
            value => Self::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v0_52", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_52")))]
impl StaticType for TextBlinkMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::vte_text_blink_mode_get_type()) }
    }
}

#[cfg(any(feature = "v0_52", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_52")))]
impl glib::value::ValueType for TextBlinkMode {
    type Type = Self;
}

#[cfg(any(feature = "v0_52", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_52")))]
unsafe impl<'a> FromValue<'a> for TextBlinkMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v0_52", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v0_52")))]
impl ToValue for TextBlinkMode {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "VteWriteFlags")]
pub enum WriteFlags {
    #[doc(alias = "VTE_WRITE_DEFAULT")]
    Default,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for WriteFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "WriteFlags::{}",
            match *self {
                Self::Default => "Default",
                _ => "Unknown",
            }
        )
    }
}

#[doc(hidden)]
impl IntoGlib for WriteFlags {
    type GlibType = ffi::VteWriteFlags;

    fn into_glib(self) -> ffi::VteWriteFlags {
        match self {
            Self::Default => ffi::VTE_WRITE_DEFAULT,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::VteWriteFlags> for WriteFlags {
    unsafe fn from_glib(value: ffi::VteWriteFlags) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::VTE_WRITE_DEFAULT => Self::Default,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for WriteFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::vte_write_flags_get_type()) }
    }
}

impl glib::value::ValueType for WriteFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for WriteFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for WriteFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}
